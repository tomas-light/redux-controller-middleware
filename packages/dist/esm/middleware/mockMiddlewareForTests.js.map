{"version":3,"file":"mockMiddlewareForTests.js","sourceRoot":"","sources":["../../../redux-controller-middleware/src/middleware/mockMiddlewareForTests.ts"],"names":[],"mappings":"AAAA,OAAO,EAAkB,aAAa,EAAE,MAAM,UAAU,CAAC;AAEzD,OAAO,EAAE,cAAc,EAAE,MAAM,sBAAsB,CAAC;AACtD,OAAO,EAAE,6BAA6B,EAAE,MAAM,wBAAwB,CAAC;AAEvE,OAAO,EAAE,oBAAoB,EAAE,MAAM,2BAA2B,CAAC;AA0CjE;;;;;;;;KAQK;AACL,MAAM,UAAU,sBAAsB,CACpC,cAA2B,EAAiB;IAM5C,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,CAAiC,CAAC;IAE5E,MAAM,KAAK,GAAG,EAAW,CAAC;IAC1B,MAAM,yBAAyB,GAAG,IAAI,GAAG,EAA6C,CAAC;IAEvF,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,cAAc,EAAE,qBAAqB,CAAC,EAAE,EAAE;QAC1D,MAAM,UAAU,GAAG,IAAI,qBAAqB,EAAE,CAAC;QAC/C,KAAK,CAAC,cAAc,CAAC,GAAG,UAAU,CAAC;QAEnC,MAAM,gBAAgB,GAAG,6BAA6B,CAAC,qBAAqB,CAAC,CAAC;QAC9E,yBAAyB,CAAC,GAAG,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC;IAC9D,CAAC,CAAC,CAAC;IAEH,MAAM,iBAAiB,GAAuB,EAAE,CAAC;IAEjD,MAAM,aAAa,GAAmC;QACpD,QAAQ,EAAE,CAAC,MAAM,EAAE,EAAE;YACnB,iBAAiB,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,OAAO,EAAE,MAAM,CAAC,OAAO;aACxB,CAAC,CAAC;YAEH,MAAM,UAAU,GAAG,yBAAyB,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAE9D,IAAI,UAAU,IAAI,MAAM,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;gBACzC,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;YAC5C,CAAC;YAED,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YAClC,OAAO,MAAM,CAAC;QAChB,CAAC;QACD,QAAQ,EAAE,GAAG,EAAE,CAAC,KAAK;KACtB,CAAC;IAEF,MAAM,SAAS,GAAG,IAAI,aAAa,EAAE,CAAC;IAEtC,MAAM,0BAA0B,GAAG,oBAAoB,CAAQ;QAC7D,SAAS;KACV,CAAC,CAAC,aAAa,CAAC,CAAC;IAElB,MAAM,QAAQ,GAAG,KAAK,EAAE,MAAuB,EAAE,EAAE;QACjD,0BAA0B,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QAC7C,MAAM,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC,CAAC;IAEF,OAAO;QACL,SAAS;QACT,KAAK;QACL,QAAQ;QACR,iBAAiB;KAClB,CAAC;AACJ,CAAC","sourcesContent":["import { type Container, ContainerImpl } from 'cheap-di';\nimport type { Dispatch, MiddlewareAPI } from 'redux';\nimport { actionPromises } from '../actionPromises.js';\nimport { getStoreSliceUpdateActionType } from '../decorators/index.js';\nimport type { Action, Constructor } from '../types/index.js';\nimport { controllerMiddleware } from './controllerMiddleware.js';\n\nexport type DispatchedAction<Payload = unknown> = {\n  type: string;\n  payload: Payload;\n};\n\nexport type MockedMiddlewareForTest<StoreSlices extends Record<string, Constructor>> = {\n  /** container instance, it allows you to mock any dependency you wish per test */\n  container: Container;\n\n  /**\n   * store, to apply assertions based on changed data in the slice\n   * @example\n   * const { state } = mockMiddlewareFoTests(...)\n   * expect(state.mySlice.myData).toBe(...)\n   * */\n  state: {\n    [sliceName in keyof StoreSlices]: InstanceType<StoreSlices[sliceName]>;\n  };\n\n  /**\n   * mocked dispatching\n   * @example\n   * test('', () => {\n   *   const { dispatch } = mockMiddlewareFoTests(UsersSlice, 'users');\n   *   await dispatch(UserController.fetchUsers())\n   *   expect(...)\n   * }\n   * */\n  dispatch: (action: Action<unknown>) => Promise<void>;\n\n  /**\n   * dispatched actions list to check actions order or content\n   * @example\n   * const { actions } = mockMiddlewareFoTests(...)\n   * const [firstAction] = actions\n   * expect(firstAction.type).toBe('my action type')\n   * */\n  dispatchedActions: DispatchedAction[];\n};\n\n/**\n * it helps you to mock the middleware for unit-tests\n * @example\n * const mockedMiddleware = mockMiddlewareForTests({ users: UsersSlice });\n * const { dispatch, state } = mockedMiddleware;\n *\n * await dispatch(UsersController.fetchUsers());\n * expect(state.users.list).toEqual([...]);\n * */\nexport function mockMiddlewareForTests<StoreSlices extends Record<string, Constructor> = Record<never, Constructor>>(\n  storeConfig: StoreSlices = {} as StoreSlices\n): MockedMiddlewareForTest<StoreSlices> {\n  type State = {\n    [sliceName in keyof StoreSlices]: InstanceType<StoreSlices[sliceName]>;\n  };\n\n  const entries = Object.entries(storeConfig) as [keyof State, Constructor][];\n\n  const state = {} as State;\n  const storeUpdateActionTypesMap = new Map<string, InstanceType<StoreSlices[string]>>();\n\n  entries.forEach(([storeSliceName, storeSliceConstructor]) => {\n    const storeSlice = new storeSliceConstructor();\n    state[storeSliceName] = storeSlice;\n\n    const updateActionType = getStoreSliceUpdateActionType(storeSliceConstructor);\n    storeUpdateActionTypesMap.set(updateActionType, storeSlice);\n  });\n\n  const dispatchedActions: DispatchedAction[] = [];\n\n  const middlewareAPI: MiddlewareAPI<Dispatch, State> = {\n    dispatch: (action) => {\n      dispatchedActions.push({\n        type: action.type,\n        payload: action.payload,\n      });\n\n      const storeSlice = storeUpdateActionTypesMap.get(action.type);\n\n      if (storeSlice && action.payload != null) {\n        Object.assign(storeSlice, action.payload);\n      }\n\n      actionPromises.resolveAll(action);\n      return action;\n    },\n    getState: () => state,\n  };\n\n  const container = new ContainerImpl();\n\n  const mockedControllerMiddleware = controllerMiddleware<State>({\n    container,\n  })(middlewareAPI);\n\n  const dispatch = async (action: Action<unknown>) => {\n    mockedControllerMiddleware(() => {})(action);\n    await actionPromises.add(action);\n  };\n\n  return {\n    container,\n    state,\n    dispatch,\n    dispatchedActions,\n  };\n}\n"]}