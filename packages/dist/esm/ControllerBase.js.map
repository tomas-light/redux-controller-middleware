{"version":3,"file":"ControllerBase.js","sourceRoot":"","sources":["../../redux-controller-middleware/src/ControllerBase.ts"],"names":[],"mappings":";;;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAElC,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAChD,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AAEnD,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAC;AAGlD,IAAM,cAAc,sBAApB,MAAM,cAAc;IAQN;IALA,QAAQ,CAA4B;IACpC,QAAQ,CAAc;IAEzC,YACE,UAA6B,EACZ,UAA4C;QAA5C,eAAU,GAAV,UAAU,CAAkC;QAE7D,IAAI,GAAG,CAAC,MAAM,KAAK,gBAAc,EAAE,CAAC;YAClC,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,CAAC,QAAQ,GAAG,CAAC,GAAG,OAAO,EAAE,EAAE,CAAC,UAAU,EAAE,QAAQ,CAAC,GAAG,OAAO,CAAC,CAAC;QACjE,IAAI,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,UAAU,EAAE,QAAQ,EAAE,CAAC;IAC/C,CAAC;IAED;;;;;;;;;;;;;;;;;;;;SAoBK;IACK,KAAK,CAAC,gBAAgB,CAAC,YAAyC;QACxE,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;QAE5B,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,gGAAgG,CAAC,CAAC;QACpH,CAAC;QAED,MAAM,UAAU,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC9E,CAAC;CACF,CAAA;AAhDY,cAAc;IAD1B,MAAM,CAAC,UAAU,CAAC;GACN,cAAc,CAgD1B","sourcesContent":["import { inject } from 'cheap-di';\nimport type { Dispatch } from 'redux';\nimport { waitAction } from './actions/index.js';\nimport { Middleware } from './middleware/index.js';\nimport type { Action, Constructor, Controller } from './types/index.js';\nimport { updateStoreSlice } from './updateStoreSlice.js';\n\n@inject(Middleware)\nexport class ControllerBase<StoreSliceInstance, State extends Record<string, unknown> = Record<string, unknown>>\n  implements Controller<State>\n{\n  protected readonly dispatch: Dispatch<Action<unknown>>;\n  protected readonly getState: () => State;\n\n  constructor(\n    middleware: Middleware<State>,\n    private readonly storeSlice?: Constructor<StoreSliceInstance>\n  ) {\n    if (new.target === ControllerBase) {\n      throw new Error('Cannot construct ControllerBase instance directly');\n    }\n\n    this.dispatch = (...actions) => middleware?.dispatch(...actions);\n    this.getState = () => middleware?.getState();\n  }\n\n  /**\n   * You may wait until the store will be updated.\n   *\n   * There is setTimeout(() => resolve) called before returning changed slice in slice reducer.\n   *\n   * So we assume, the action will be resolved after changes will be applied to the redux state\n   * @example\n   *   \\@reducer\n   *   async fetchUsers() {\n   *     const users = await this.userApi.get();\n   *\n   *     await this.updateStoreSlice({\n   *       usersList: users,\n   *     });\n   *\n   *     console.log('executed');\n   *\n   *     const { usersList } = this.getState().users;\n   *     console.log(`list is updated ${usersList === users}`);\n   *   }\n   * */\n  protected async updateStoreSlice(partialStore: Partial<StoreSliceInstance>) {\n    const { storeSlice } = this;\n\n    if (!storeSlice) {\n      throw new Error('You have to pass storeSlice to ControllerBase\\'s \"super\" to use \"this.updateStoreSlice\" method');\n    }\n\n    await waitAction(updateStoreSlice(storeSlice)(partialStore), this.dispatch);\n  }\n}\n"]}