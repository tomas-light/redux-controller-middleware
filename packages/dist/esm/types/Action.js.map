{"version":3,"file":"Action.js","sourceRoot":"","sources":["../../../redux-controller-middleware/src/types/Action.ts"],"names":[],"mappings":"","sourcesContent":["import { UnknownAction } from 'redux';\n\nexport interface Action<Payload = undefined> extends UnknownAction {\n  payload: Payload;\n\n  /** next actions chain (actions that will be dispatched after handling of this one) */\n  readonly actions: (ActionFactory | Action<unknown>)[];\n\n  /** is action chain stopped or not */\n  readonly stopPropagation: boolean;\n\n  /**\n   * Add an action (or actions) that will be dispatched right after of executing this action.\n   * @example\n   * const authorizeAction = createAction('AUTH');\n   * const loadProfileAction = createAction('LOAD_MY_PROFILE');\n   * const loadSettingsAction = createAction('LOAD_MY_SETTINGS');\n   * authorizeAction.addNextActions(loadProfileAction, loadSettingsAction);\n   * dispatch(authorizeAction);\n   * */\n  addNextActions(...actions: Action<unknown>['actions']): Action<Payload>;\n\n  /** If the action has next actions in chain, this method stops them from dispatching */\n  stop(): void;\n\n  /** returns `next actions chain of this action */\n  // getActions(): Action['actions'];\n\n  /**\n   * if action has next actions, the middleware will add promise resolving\n   * to this property, that will be triggered after all next action will be handled.\n   * It is signal for the middleware: this action was handled, and we can take\n   * next action in a chain.\n   *\n   * Also, it is used for store updating, if you would like to wait till store was updated and then do some work dependent on it.\n   * Such resolving is settled only in ControllerBase.updateStoreSlice method\n   * */\n  executionCompleted?: () => void;\n}\n\nexport type ActionFactory = () => Action<unknown> | void | Promise<void>;\n"]}