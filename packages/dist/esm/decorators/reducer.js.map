{"version":3,"file":"reducer.js","sourceRoot":"","sources":["../../../redux-controller-middleware/src/decorators/reducer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,uBAAuB,EAAE,MAAM,iBAAiB,CAAC;AA+B1D;;;KAGK;AACL,MAAM,CAAC,MAAM,OAAO,GAAqB,CAAC,CAAC,MAAe,EAAE,aAAwC,EAAE,EAAE;IACtG,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE,CAAC;QACtC,uBAAuB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC5C,OAAO;IACT,CAAC;IAED,IAAI,OAAO,aAAa,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;QAC3C,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACnD,CAAC;IAED,QAAQ,aAAa,CAAC,IAAI,EAAE,CAAC;QAC3B,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ;YACX,uBAAuB,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACjD,OAAO,MAAM,CAAC;QAEhB,KAAK,UAAU,CAAC;QAChB,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ,CAAC;QACd,KAAK,QAAQ,CAAC;QACd;YACE,MAAM,IAAI,KAAK,CAAC,kFAAkF,CAAC,CAAC;IACxG,CAAC;AACH,CAAC,CAAqB,CAAC","sourcesContent":["import { methodNamesTemporaryBox } from '../constants.js';\nimport { Action } from '../types/index.js';\n\nexport interface ReducerMethodDecorator {\n  // stage 3 decorator\n  <This, TPayload, Args extends Action<TPayload>[], Return>(\n    method: (this: This, ...args: Args) => Return,\n    methodContext: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>\n  ): (this: This, ...args: Args) => Return;\n\n  // stage 2 decorator\n  <This, TPayload, Args extends Action<TPayload>[], Return>(\n    method: (this: This, ...args: Args) => Return,\n    methodName: string,\n    descriptor: PropertyDescriptor\n  ): void;\n}\n\nexport interface ReducerPropertyDecorator {\n  // stage 3 decorator\n  <This, TPayload, Args extends Action<TPayload>[], Return>(\n    target: undefined, // is it always undefined for field decorators\n    fieldContext: ClassFieldDecoratorContext<This, (this: This, ...args: Args) => Return>\n  ): void;\n\n  // stage 2 decorator\n  (classPrototype: any, propertyName: string): void;\n}\n\nexport interface ReducerDecorator extends ReducerMethodDecorator, ReducerPropertyDecorator {}\n\n/**\n * It marks your method as action handler, you have to use `@reduxController` decorator on the class as well,\n * to register this method in the middleware\n * */\nexport const reducer: ReducerDecorator = ((method: unknown, contextOrName: DecoratorContext | string) => {\n  if (typeof contextOrName === 'string') {\n    methodNamesTemporaryBox.push(contextOrName);\n    return;\n  }\n\n  if (typeof contextOrName.name === 'symbol') {\n    throw new Error('Cannot decorate symbol names.');\n  }\n\n  switch (contextOrName.kind) {\n    case 'field':\n    case 'method':\n      methodNamesTemporaryBox.push(contextOrName.name);\n      return method;\n\n    case 'accessor':\n    case 'class':\n    case 'getter':\n    case 'setter':\n    default:\n      throw new Error('Decorator can be used only for method and bounded methods (arrow function style)');\n  }\n}) as ReducerDecorator;\n"]}