{"version":3,"file":"controller.js","sourceRoot":"","sources":["../../../redux-controller-middleware/src/decorators/controller.ts"],"names":[],"mappings":";;;AAAA,gEAA0D;AAC1D,kDAAiF;AAEjF,2DAAqD;AA0BrD;;KAEK;AACQ,QAAA,UAAU,GAA6B,CAAC,CAAC,iBAAiB,EAAE,OAAO,EAAE,EAAE;IAClF,IAAI,OAAO,iBAAiB,KAAK,QAAQ,EAAE,CAAC;QAC1C,OAAO,0BAA0B,CAAC,iBAAiB,CAAC,CAAC;IACvD,CAAC;IAED,gFAAgF;IAChF,MAAM,UAAU,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC,QAAQ,EAAE,CAAC;IACnD,OAAO,0BAA0B,CAAC,UAAU,CAAC,CAAC,iBAAiB,EAAE,OAAO,CAAC,CAAC;AAC5E,CAAC,CAA6B,CAAC;AAE/B,MAAM,0BAA0B,GAA0C,CAAC,CAAC,UAAU,EAAE,EAAE;IACxF,OAAO,CAAC,WAAW,EAAE,OAAO,EAAE,EAAE;QAC9B,MAAM,kBAAkB,GAAG,qBAAqB,EAAE,CAAC;QACnD,MAAM,cAAc,GAAG,OAAO,EAAE,IAAI,IAAI,WAAW,CAAC,IAAI,CAAC;QAEzD,kBAAkB,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;YACxC,MAAM,UAAU,GAAG,IAAA,kCAAc,EAAC;gBAChC,cAAc;gBACd,UAAU;gBACV,UAAU;aACX,CAAC,CAAC;YAEH,wBAAwB,CAAC;gBACvB,WAAW;gBACX,UAAU;gBACV,UAAU;aACX,CAAC,CAAC;YAEH,8BAA8B,CAAC,WAAW,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QACtE,CAAC,CAAC,CAAC;QAEH,OAAO,WAAW,CAAC;IACrB,CAAC,CAAC;AACJ,CAAC,CAA0C,CAAC;AAE5C,SAAS,qBAAqB;IAC5B,MAAM,kBAAkB,GAAG,sCAAuB,CAAC,KAAK,EAAE,CAAC;IAC3D,sCAAuB,CAAC,MAAM,CAAC,CAAC,EAAE,sCAAuB,CAAC,MAAM,CAAC,CAAC;IAElE,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAED,SAAS,wBAAwB,CAAC,UAAgF;IAChH,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,UAAU,CAAC;IAE3D,IAAI,iBAAiB,GAAG,oCAAqB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IAC9D,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACvB,iBAAiB,GAAG,IAAI,GAAG,EAAE,CAAC;QAC9B,oCAAqB,CAAC,GAAG,CAAC,UAAU,EAAE,iBAAiB,CAAC,CAAC;IAC3D,CAAC;IAED,IAAI,OAAO,iBAAiB,KAAK,UAAU,EAAE,CAAC;QAC5C,6GAA6G;QAC7G,MAAM,IAAI,KAAK,CACb,kKAAkK,CACnK,CAAC;IACJ,CAAC;IAED,iBAAiB,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;AACjD,CAAC;AAED,SAAS,8BAA8B,CAAC,WAAwB,EAAE,UAAkB,EAAE,UAAkB;IACtG,MAAM,aAAa,GAAG,CAAC,OAAa,EAAE,EAAE,CAAC,IAAA,8BAAY,EAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC3E,WAAW,CAAC,UAAsC,CAAC,GAAG,aAA+D,CAAC;AACxH,CAAC","sourcesContent":["import { createAction } from '../actions/createAction.js';\nimport { actionToControllerMap, methodNamesTemporaryBox } from '../constants.js';\nimport type { Constructor, Controller, ControllerConstructor } from '../types/index.js';\nimport { makeActionType } from './makeActionType.js';\n\nexport interface Class_ReduxControllerDecorator {\n  // stage 3 decorator\n  <TController extends Controller, TConstructor extends ControllerConstructor<TController>>(\n    constructor: TConstructor,\n    context: ClassDecoratorContext\n  ): TConstructor;\n\n  // stage 2 decorator\n  <TController extends Controller, TConstructor extends ControllerConstructor<TController>>(\n    constructor: TConstructor\n  ): TConstructor;\n}\nexport interface ClassFactory_ReduxControllerDecorator {\n  /**\n   * @param nameSalt {string} is used to add unique salt to action name to avoid collisions, if you have a few controllers with the same name and method names.\n   * But if this is your intention, you may pass empty string to disable salt adding to the controller\n   * */\n  (nameSalt: string): Class_ReduxControllerDecorator;\n}\n\nexport interface ReduxControllerDecorator\n  extends Class_ReduxControllerDecorator,\n    ClassFactory_ReduxControllerDecorator {}\n\n/**\n * It registers your controller in the middleware. You need to add `@actionHandler` decorator to some of your methods\n * */\nexport const controller: ReduxControllerDecorator = ((saltOrConstructor, context) => {\n  if (typeof saltOrConstructor === 'string') {\n    return reduxFactoryClassDecorator(saltOrConstructor);\n  }\n\n  // to prevent names collisions, when you have two controllers with the same name\n  const uniqueSalt = new Date().valueOf().toString();\n  return reduxFactoryClassDecorator(uniqueSalt)(saltOrConstructor, context);\n}) as ReduxControllerDecorator;\n\nconst reduxFactoryClassDecorator: ClassFactory_ReduxControllerDecorator = ((uniqueSalt) => {\n  return (constructor, context) => {\n    const watchedMethodNames = getWatchedMethodNames();\n    const controllerName = context?.name ?? constructor.name;\n\n    watchedMethodNames.forEach((methodName) => {\n      const actionType = makeActionType({\n        controllerName,\n        methodName,\n        uniqueSalt,\n      });\n\n      registerControllerMethod({\n        constructor,\n        methodName,\n        actionType,\n      });\n\n      addActionCreatorAsStaticMethod(constructor, actionType, methodName);\n    });\n\n    return constructor;\n  };\n}) as ClassFactory_ReduxControllerDecorator;\n\nfunction getWatchedMethodNames() {\n  const watchedMethodNames = methodNamesTemporaryBox.slice();\n  methodNamesTemporaryBox.splice(0, methodNamesTemporaryBox.length);\n\n  return watchedMethodNames;\n}\n\nfunction registerControllerMethod(parameters: { constructor: Constructor; methodName: string; actionType: string }) {\n  const { constructor, actionType, methodName } = parameters;\n\n  let actionControllers = actionToControllerMap.get(actionType);\n  if (!actionControllers) {\n    actionControllers = new Map();\n    actionToControllerMap.set(actionType, actionControllers);\n  }\n\n  if (typeof actionControllers === 'function') {\n    // action reducers have to has unique action type for them, so collisions with controllers should not happens\n    throw new Error(\n      'There is already registered action reducer for this action type. Probably, it is a bug in redux-controller-middleware. Please report it to our Issues on Github.'\n    );\n  }\n\n  actionControllers.set(constructor, methodName);\n}\n\nfunction addActionCreatorAsStaticMethod(constructor: Constructor, actionType: string, methodName: string) {\n  const actionCreator = (payload?: any) => createAction(actionType, payload);\n  constructor[methodName as keyof typeof constructor] = actionCreator as (typeof constructor)[keyof typeof constructor];\n}\n"]}